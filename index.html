<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Roguelike Chess — Fixed</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--size:64px}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#f3f4f6;margin:0;padding:20px;display:flex;flex-direction:column;align-items:center}
  h1{margin:0 0 12px}
  #board{display:grid;grid-template-columns:repeat(8,var(--size));grid-auto-rows:var(--size);gap:0;border-radius:8px;box-shadow:0 6px 20px rgba(2,6,23,0.08)}
  .square{width:var(--size);height:var(--size);display:flex;align-items:center;justify-content:center;font-size:32px;user-select:none}
  .light{background:#f0d9b5}
  .dark{background:#b58863}
  .highlight{outline:3px solid rgba(125,211,252,0.9);box-shadow:0 0 12px rgba(125,211,252,0.08)}
  #controls{margin-top:12px;display:flex;gap:8px}
  #log{margin-top:12px;width:524px;height:120px;overflow:auto;background:#fff;border:1px solid #e2e8f0;padding:8px;border-radius:8px;font-size:13px;color:#0f172a}
  button{padding:8px 10px;border-radius:8px;border:1px solid #cbd5e1;background:white;cursor:pointer}
  .muted{color:#475569;font-size:13px;margin-top:8px}
</style>
</head>
<body>
  <h1>Roguelike Chess (fixed)</h1>
  <div id="board" aria-label="chess board"></div>
  <div id="controls">
    <button id="newGame">New Game</button>
    <button id="aiMove">AI Move</button>
    <div class="muted" id="turnIndicator">turn: —</div>
  </div>
  <div id="log"></div>

<script>
// Robust single-file chess UI.
// Fixes: safe fallback if chess.js is unavailable, correct square->coordinate mapping, proper piece glyphs,
// prevents script from crashing if library fails to load, shows easy debugging logs.

const FILES = 'abcdefgh';
const boardEl = document.getElementById('board');
const logEl = document.getElementById('log');
const turnIndicator = document.getElementById('turnIndicator');

const pieceIcons = { p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚', P:'♙', R:'♖', N:'♘', B:'♗', Q:'♕', K:'♔' };

function log(msg){ const d = document.createElement('div'); d.textContent = msg; logEl.prepend(d); }

// Minimal fallback Chess implementation (if chess.js not available)
function MiniChess(){
  // rows 0..7 correspond to ranks 8..1
  this._board = [
    [{type:'r',color:'b'},{type:'n',color:'b'},{type:'b',color:'b'},{type:'q',color:'b'},{type:'k',color:'b'},{type:'b',color:'b'},{type:'n',color:'b'},{type:'r',color:'b'}],
    Array(8).fill().map(()=>({type:'p',color:'b'})),
    Array(8).fill(null),Array(8).fill(null),Array(8).fill(null),Array(8).fill(null),
    Array(8).fill().map(()=>({type:'p',color:'w'})),
    [{type:'r',color:'w'},{type:'n',color:'w'},{type:'b',color:'w'},{type:'q',color:'w'},{type:'k',color:'w'},{type:'b',color:'w'},{type:'n',color:'w'},{type:'r',color:'w'}]
  ];
  this._turn = 'w';
  this._hist = [];
}
MiniChess.prototype.board = function(){ return this._board.map(r=>r.map(c=>c?{type:c.type,color:c.color}:null)); };
MiniChess.prototype.turn = function(){ return this._turn; };
MiniChess.prototype.moves = function(opts){
  // naive generator: returns SAN strings OR verbose objects if requested
  const out = [];
  for(let r=0;r<8;r++) for(let f=0;f<8;f++){
    const p = this._board[r][f]; if(!p) continue; if(opts && opts.square){ const sf = FILES.indexOf(opts.square[0]); const sr = 8 - parseInt(opts.square[1],10); if(sf!==f || sr!==r) continue; }
    if(p.color !== this._turn) continue;
    const from = FILES[f] + (8 - r);
    // generate pseudo-legal targets (simple)
    let targets = [];
    if(p.type==='p'){
      const dir = p.color==='w' ? -1 : 1; const nr = r + dir; if(nr>=0&&nr<8 && !this._board[nr][f]) targets.push(FILES[f]+(8-nr)); // forward
      for(const df of [-1,1]){ const cf = f+df; const nr2 = r+dir; if(cf>=0&&cf<8 && nr2>=0&&nr2<8){ const occ = this._board[nr2][cf]; if(occ && occ.color!==p.color) targets.push(FILES[cf]+(8-nr2)); }}
    } else if(p.type==='n'){
      const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
      for(const [df,dr] of deltas){ const nf=f+df,nr=r+dr; if(nf>=0&&nf<8&&nr>=0&&nr<8){ const occ=this._board[nr][nf]; if(!occ || occ.color!==p.color) targets.push(FILES[nf]+(8-nr)); }}
    } else {
      const dirs = p.type==='b'?[[1,1],[1,-1],[-1,1],[-1,-1]]:p.type==='r'?[[1,0],[-1,0],[0,1],[0,-1]]:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
      for(const [df,dr] of dirs){ let nf=f+df,nr=r+dr; while(nf>=0&&nf<8&&nr>=0&&nr<8){ const occ=this._board[nr][nf]; if(!occ) targets.push(FILES[nf]+(8-nr)); else { if(occ.color!==p.color) targets.push(FILES[nf]+(8-nr)); break; } nf+=df; nr+=dr; }}
    }
    if(opts && opts.verbose){ for(const to of targets){ const tf = FILES.indexOf(to[0]); const tr = 8-parseInt(to[1],10); const captured = this._board[tr][tf] ? this._board[tr][tf].type : null; out.push({from, to, captured}); }} else { for(const to of targets) out.push(from+to); }
  }
  return out;
};
MiniChess.prototype.move = function(m){
  // accepts san string or object {from,to}
  if(typeof m === 'string'){
    // not implemented: fallback random move on san
    return null;
  }
  const from = m.from; const to = m.to; const ff = FILES.indexOf(from[0]); const fr = 8 - parseInt(from[1],10); const tf = FILES.indexOf(to[0]); const tr = 8 - parseInt(to[1],10);
  const piece = this._board[fr][ff]; if(!piece) return null; const captured = this._board[tr][tf] ? this._board[tr][tf].type : null;
  this._hist.push({from,to,piece:{...piece},captured});
  this._board[tr][tf] = {type: m.promotion ? m.promotion : piece.type, color: piece.color};
  this._board[fr][ff] = null;
  this._turn = this._turn === 'w' ? 'b' : 'w';
  return {from,to,captured,piece:piece.type};
};
MiniChess.prototype.undo = function(){ const h = this._hist.pop(); if(!h) return null; const ff = FILES.indexOf(h.from[0]); const fr = 8-parseInt(h.from[1],10); const tf = FILES.indexOf(h.to[0]); const tr = 8-parseInt(h.to[1],10); this._board[fr][ff] = {...h.piece}; this._board[tr][tf] = h.captured ? {type:h.captured, color: this._board[tr][tf] ? this._board[tr][tf].color : 'b'} : null; this._turn = this._turn === 'w' ? 'b' : 'w'; return h; };
MiniChess.prototype.game_over = function(){ return false; };

// Create game using Chess if available or fallback otherwise
const ChessGlobal = (typeof window.Chess !== 'undefined') ? window.Chess : null;
const GameCtor = ChessGlobal || MiniChess;
const game = new GameCtor();

// helpers
function squareLabel(fileIdx,rowIdx){ // rowIdx corresponds to board() row index (0=rank8..7=rank1)
  return FILES[fileIdx] + (8 - rowIdx);
}

function render(){
  try{
    boardEl.innerHTML = '';
    const b = game.board();
    for(let row = 0; row < 8; row++){
      for(let f = 0; f < 8; f++){
        // We want top-left = a8, so iterate row 0..7
        const square = document.createElement('div');
        const isLight = ((f + (7 - row)) % 2) === 0; // adjust so a8 is light
        square.className = 'square ' + (isLight ? 'light' : 'dark');
        const sqName = squareLabel(f, row);
        square.dataset.square = sqName;
        const piece = b[row][f];
        if(piece){ const glyph = (piece.color === 'w') ? pieceIcons[piece.type.toUpperCase()] : pieceIcons[piece.type]; square.textContent = glyph; }
        square.addEventListener('click', ()=>onSquareClick(sqName));
        boardEl.appendChild(square);
      }
    }
    updateTurnIndicator();
  }catch(err){ console.error('Render error', err); log('Render error: '+err.message); }
}

let picked = null;
function onSquareClick(sq){
  if(game.turn && game.turn() !== 'w') return; // only allow player when it's white's turn
  const moves = game.moves ? game.moves({square: sq, verbose: true}) : [];
  if(!picked){
    // pick if there are legal moves from this square
    if(moves && moves.length){ picked = sq; highlightMoves(moves); }
    return;
  }
  // attempt to move
  // if game.move accepts object, use that to obtain move object
  const moveObj = game.move({from: picked, to: sq, promotion: 'q'});
  clearHighlights(); picked = null;
  if(moveObj){ handleCapture(moveObj); render(); setTimeout(()=> aiTurn(), 120); }
}

function highlightMoves(moves){ clearHighlights(); if(!moves) return; moves.forEach(m=>{ const el = document.querySelector(`[data-square='${m.to}']`); if(el) el.classList.add('highlight'); }); }
function clearHighlights(){ document.querySelectorAll('.highlight').forEach(x=>x.classList.remove('highlight')); }

function aiTurn(){
  try{
    if(!game.moves) return;
    const moves = game.moves();
    if(!moves || moves.length===0) return;
    // simple fast AI: evaluate random sample + prefer captures
    // pick capture if available
    if(typeof moves[0] === 'object'){
      // verbose objects from fallback
      const caps = moves.filter(m=>m.captured);
      const pick = caps.length ? caps[Math.floor(Math.random()*caps.length)] : moves[Math.floor(Math.random()*moves.length)];
      game.move(pick);
    } else {
      // string SAN or UCI
      // try choose a capture SAN if present (contains 'x')
      const caps = moves.filter(m=> m.indexOf('x') !== -1);
      const pick = caps.length ? caps[Math.floor(Math.random()*caps.length)] : moves[Math.floor(Math.random()*moves.length)];
      game.move(pick);
    }
    render();
  }catch(err){ console.error('AI error', err); log('AI error: '+err.message); }
}

function handleCapture(move){
  const captured = (move && (move.captured || move.captured === 0)) ? move.captured : (typeof move === 'object' && move.captured ? move.captured : null);
  if(captured){ const capturer = move.piece || (typeof move === 'object' && move.piece) || '?'; log(`Captured ${captured} by ${capturer}`); /* upgrades handling here */ }
}

function updateTurnIndicator(){ if(game.turn) turnIndicator.textContent = 'turn: ' + (game.turn() === 'w' ? 'White (you)' : 'Black (AI)'); }

// controls
document.getElementById('newGame').addEventListener('click', ()=>{ if(typeof GameCtor === 'function') { // recreate
  try{ const g = new GameCtor(); window._game = g; // temporary
  location.reload(); } catch(e){ location.reload(); } } });

document.getElementById('aiMove').addEventListener('click', ()=>aiTurn());

// initial render
render();

</script>
</body>
</html>
